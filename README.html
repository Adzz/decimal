<!DOCTYPE html>
<html>
  <head>
    <title>README</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

    <script type="text/javascript" charset="utf-8">
      relpath = '';
      if (relpath != '') relpath += '/';
    </script>

    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/app.js"></script>
  </head>

  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>

    <div id="content">
      <div class="breadcrumbs">Decimal v0.1.1 &rarr; <a href="readme.html">README</a></div>
      <h1>Decimal</h1>

<p><a href="https://travis-ci.org/ericmj/decimal"><img src="https://travis-ci.org/ericmj/decimal.svg?branch=master" alt="Build Status"></a></p>

<p>Arbitrary precision decimal arithmetic for Elixir.</p>

<p>Documentation: <a href="http://ericmj.github.io/decimal">http://ericmj.github.io/decimal</a></p>

<h2>Usage</h2>

<p>Add Decimal as a dependency in your <code>mix.exs</code> file.</p>

<pre><code class="elixir">def deps do
  [ { :decimal, github: &quot;ericmj/decimal&quot; } ]
end
</code></pre>

<p>After you are done, run <code>mix deps.get</code> in your shell to fetch and compile Decimal. Start an interactive Elixir shell with <code>iex -S mix</code>.</p>

<pre><code class="iex">iex&gt; alias Decimal, as: D
nil
iex&gt; D.add(D.new(6), D.new(7))
#Decimal&lt;13&gt;
iex&gt; D.div(D.new(1), D.new(3))
#Decimal&lt;0.333333333&gt;

</code></pre>

<h2>Examples</h2>

<h3>Using the context</h3>

<p>The context specifies the maximum precision of the result of calculations and
the rounding algorithm if the result has a higher precision than the specified
maximum. It also holds the list of set of trap enablers and the currently set
flags.</p>

<p>The context is stored in the process dictionary, this means that you don&#39;t have
to pass the context around explicitly and the flags will be updated
automatically.</p>

<p>The context is accessed with <code>Decimal.get_context/0</code> and set with
<code>Decimal.set_context/1</code>. It can also be temporarily set with
<code>Decimal.with_context/2</code>.</p>

<pre><code class="iex">iex&gt; D.get_context
Decimal.Context[precision: 9, rounding: :half_up, flags: [],
 traps: [:invalid_operation, :division_by_zero]]
iex&gt; D.with_context Context[precision: 2], fn -&gt; IO.inspect D.get_context end
Decimal.Context[precision: 2, rounding: :half_up, flags: [],
 traps: [:invalid_operation, :division_by_zero]]
:ok
iex&gt; D.set_context(D.get_context.traps([]))
:ok
iex&gt; Decimal.get_context
Decimal.Context[precision: 9, rounding: :half_up, flags: [], traps: []]
</code></pre>

<h3>Precision and rounding</h3>

<p>The precision is used to limit the amount of decimal digits in the coefficient:</p>

<pre><code class="iex">iex&gt; D.set_context(D.get_context.precision(9))
:ok
iex&gt; D.div(D.new(1), D.new(3))
#Decimal&lt;0.333333333&gt;
iex&gt; D.set_context(D.get_context.precision(2))
:ok
iex&gt; D.div(D.new(1), D.new(3))
#Decimal&lt;0.33&gt;
</code></pre>

<p>The rounding algorithm specifies how the result of an operation shall be rounded
when it get be represented with the current precision:</p>

<pre><code class="iex">iex&gt; D.set_context(D.get_context.rounding(:half_up))
:ok
iex&gt; D.div(D.new(31), D.new(2))
#Decimal&lt;16&gt;
iex&gt; D.set_context(D.get_context.rounding(:floor))
:ok
iex&gt; D.div(D.new(31), D.new(2))
#Decimal&lt;15&gt;
</code></pre>

<h3>Flags and trap enablers</h3>

<p>When an exceptional condition is signalled its flag is set in the context and if
if the trap enabler is set <code>Decimal.Error</code> will be raised.</p>

<pre><code class="iex">iex&gt; D.get_context.traps
[:invalid_operation, :division_by_zero]
iex&gt; D.get_context.flags
[]
iex&gt; D.div(D.new(31), D.new(2))
#Decimal&lt;15&gt;
iex&gt; D.get_context.flags
[:inexact, :rounded]
</code></pre>

<p><code>:inexact</code> and <code>:rounded</code> were signalled above because the result of the
operation was inexact given the context&#39;s precision and had to be rounded to fit
the precision. <code>Decimal.Error</code> was not raised because the signals&#39; trap enablers
weren&#39;t set. We can, however, set the trap enabler if we what this condition to
raise.</p>

<pre><code class="iex">iex&gt; D.set_context(D.get_context.update_traps((&amp;1 ++ [:inexact]))
:ok
iex&gt; D.div(D.new(31), D.new(2))
** (Decimal.Error)
</code></pre>

<p>The default trap enablers, such as <code>:division_by_zero</code> can be unset:</p>

<pre><code class="iex">iex&gt; D.get_context.traps
[:invalid_operation, :division_by_zero]
iex&gt; D.div(D.new(42), D.new(0))
** (Decimal.Error)
iex&gt; D.set_context(D.get_context.traps([]).flags([]))
:ok
iex&gt; D.div(D.new(42), D.new(0))
#Decimal&lt;Infinity&gt;
iex&gt; D.get_context.flags
[:division_by_zero]
</code></pre>

<h3>Mitigating rounding errors</h3>

<p>TODO</p>

<h2>License</h2>

<p>Copyright 2013 Eric Meadows-JÃ¶nsson</p>

<p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at</p>

<pre class="codeblock"><code>   http://www.apache.org/licenses/LICENSE-2.0
</code></pre>

<p>Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.</p>

    </div>
  </body>
</html>

